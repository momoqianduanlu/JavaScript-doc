## 深入理解javascript作用域 - 函数作用域

正如我们在前面讨论的那样，作用域包含了一系列的气泡，每一个都可以作为容器，其中包含了标识符（变量，函数）的定义。这些气泡互相嵌套并排列成蜂窝型，排列的结构是在写代码的时候定义的。

但是究竟是什么生成了一个新的气泡？只有函数会生成新的气泡吗？javascript中的其他结构能生成作用域气泡吗？



## 函数中的作用域

对于前面提出的问题，最常见的答案是 **javascript 具有基于函数的作用域**，意味着每声明一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡，但事实上这并不完全正确。



考虑下面的代码：

~~~javascript
function foo (a) {
    var b = 2
    function bar () {
        // ...
    }
    var c = 3
}
~~~

在这个代码片段中，foo(..) 的作用域气泡中包含了标识符 a, b, c 和 bar。无论标识符声明出现在作用域的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡，



bar(..) 拥有自己的作用域气泡。全局作用域也拥有自己的作用域气泡，他只包含了一个标识符：foo。

由于标识符 a, b, c 和 bar 都附属于 foo(..) 的作用域气泡，因此无法从 foo(..) 的外部对他们进行访问，也就是说，这些标识符全都无法从全局作用域中进行访问，



函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用以及复用（事实上在嵌套作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 javascript 变量可以根据需要改变值类型的 "动态" 特性。



## 隐藏内部实现

对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对他进行包装，实际上就是把这些代码隐藏起来了。

实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来"隐藏"他们。



为什么 "隐藏" 变量和函数是一个有用的技术？



有很多原因促成了这种作用域的隐藏方法，他们大都是从最小 `最小特权`原则中引申出来的，也叫最小授权或最小暴露原则。这个原则指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都 "隐藏" 起来，比如某个模块或对象的 API 设计。

例如：

~~~javascript
function doSomething (a) {
    b = a + doSomethingElse(a * 2)
    console.log(b * 3)
}

function doSomethingElse (a) {
    return a - 1
}

var b

doSomething(2) // 15
~~~



~~~javascript
function doSomething (a) {
    function doSomethingElse (a) {
        return a - 1
    }
    var b
    b = a + doSomethingElse(a * 2)
    console.log(b * 3)
}

doSomething(2) // 15
~~~





## 规避冲突

隐藏作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

例如：

~~~javascript
function foo () {
    function bar () {
        i = 3; // 修改 for 循环所属作用域中的 i
        console.log(a + i)
    }
    
    for (var i = 0; i < 10; i++) {
        bar (i * 2); // 无限循环了！
    }
}

foo()
~~~

bar(..) 内部的赋值表达式 i = 3 意外地覆盖了声明在 foo(..) 内部 for 循环中的 i。在这个例子中将会导致无限循环，因为 i 被固定设置为 3，永远满足小于 10 这个条件。

bar(..) 内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以， var i = 3；就可以满足这个需求（同时会为 i 声明一个前面提到过的 "遮蔽变量"）。另外一种方法是采用一个完全不同的标识符名称，比如 var j = 3;。



## 函数作用域

我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义 “隐藏” 起来，外部作用域无法访问包装函数内部的任何内容。

例如：

~~~javascript
var a = 2
function foo () {
    var a = 3
    console.log(a) // 3
}

foo()

console.log(a) // 2
~~~



虽然这种技术可以解决一些问题，但他并不理想，因为会导致一些额外的问题。首先，必须声明一个具名函数 foo()，意味着 foo 这个名称本身 "污染" 了所在作用域（在这个例子中是全局作用域）。其次必须显示地通过函数名（foo()）调用这个函数才能运行其中的代码。



如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。

~~~javascript
var a = 2

(function foo () {
    var a = 3
    console.log(a) // 3
})()

console.log(a) // 2
~~~

接下来我们分别介绍这里发生的事情。

首先，包装函数的声明以 (function...而不仅是以 function... 开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别，函数会被当做函数表达式而不是一个标准的函数声明来处理。

+ 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。
+ 函数声明和函数表达式之间最重要的区别就是他们的标识符将会绑定在何处。

(function foo () { .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。



## 匿名和具名

对于函数表达式你最熟悉的场景可能就是回调参数了，比如：

~~~javascript
setTimeout (function () {
    console.log('I watied 1 second')
}, 1000)
~~~



这叫做**匿名函数表达式**，因为 function ()..没有标识符，函数表达式可以是匿名的，而函数声明则不可以省略函数名 — 在 javascript 的语法中这是非法的。



## 立即执行函数表达式

~~~javascript
var a = 2

(function foo () {
    var a = 3
    console.log(a) // 3
})()

console.log(a) // 2
~~~

由于函数被包含在一对（）括号内部，因此成为了一个函数表达式，通过在末尾加上另外一个（）可以立即执行这个函数，比如 (function foo(){..})()。第一个 （）将函数变成表达式，第二个执行了这个函数。



**IIFE** 代表立即执行函数表达式；



~~~javascript
var a = 2

(function IIFE () {
    var a = 3
    console.log(a) // 3
}())

console.log(a) // 2
~~~

相较于传统的 IIFE 形式，很多人更喜欢另一个改进的形式，(function foo(){..})()。仔细观察其中的区别。第一种形式中的函数表达式被包含在（）中，然后在后面用另一个（）括号来调用。第二种形式用来调用的（）括号被移进了用来包装的（）括号中。



**IIFE** 的另一个非常普遍的进阶用法是把他们当做函数调用并传递参数进去。

例如：

~~~javascript
var a = 2

(function IIFE (global) {
    var a = 3
    console.log(a) // 3
    console.log(global.a) // 2
})(window)

console.log(a) // 2
~~~

我们将 window 对象的引用传递进去，但将参数命名为 global， 因此在代码风格上对全局对象的引用变得比引用一个没有 "全局" 字样的变量更加清晰。当然可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字，这对于改进代码风格是非常有帮助的。















