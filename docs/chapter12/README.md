# 深入理解闭包 - 什么是闭包

闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用他们而有意识的创建闭包，



下面是直截了当的定义，你需要掌握它才能理解和识别闭包。

+ 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使是在当前词法作用域之外执行。

## 定义一

闭包是指可以访问其所在作用域的函数

那这样说来，需要通过作用域链查找变量的函数就是闭包

~~~javascript
//按照定义一的说法，需要通过作用域链在全局环境中查找变量n的函数foo()就是闭包
var n = 0;
function foo() {
    console.log(n)//0
}
foo();
~~~

## 定义二

闭包是指有权访问另一个函数作用域中的变量的函数

那这样说来，访问上层函数的作用域的内层函数就是闭包

~~~javascript
//按照定义二的说法，嵌套在foo函数里的bar函数就是闭包
function foo(){
    var a = 2;
    function bar(){
        console.log(a); // 2
    }
    bar();
}
foo();
~~~

## 定义三

闭包是指在函数声明时的作用域以外的地方被调用的函数

在函数声明时的作用域以外的地方调用函数，需要通过将该函数作为返回值或者作为参数被传递

~~~javascript
//按照定义三的说法，在foo()函数的作用域中声明，在全局环境的作用域中被调用的bar()函数是闭包
function foo(){
    var a = 2;
    function bar(){
        console.log(a); //2
    }
    return bar;
}
foo()();
~~~



可以简写为如下表示：

~~~javascript
function foo(){
    var a = 2;
    return function(){
        console.log(a);//2
    }
}
foo()();
~~~



【参数】

~~~javascript
//按照定义三的说法，在foo()函数的作用域中声明，在bar()函数的作用域中被调用的baz()函数是闭包
function foo(){
    var a = 2;
    function baz(){
        console.log(a); //2
    }
    bar(baz);
}
function bar(fn){
    fn();
}
~~~



因此，无论通过何种手段，只要将内部函数传递到所在的词法作用域以外，它都会持有对原始作用域的引用，无论在何处执行这个函数都会使用闭包



下面我们来看一段代码，清晰地展示了闭包：

~~~javascript
function foo () {
    var a = 2
    function bar () {
        console.log(a)
    }
    return bar
}
var baz = foo()
baz()
~~~

函数bar()的词法作用域能够访问foo()的内部作用域。然后我们将bar()函数本身当做一个值的类型进行传递，在这个例子中，我们将bar所引用的函数对象本身当作返回值。

在foo()执行后，其返回值（也就是内部的bar函数）赋值给变量baz并调用baz()，实际上只是通过不同的标识符引用调用了内部的函数bar()。

bar()显然可以被正常执行，但是在这个例子中，他在自己定义的词法作用域以外的地方执行。

在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间，由于看上去foo()的内容不会再被使用，所以很自然地会考虑对其进行回收。

而闭包的神奇之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是bar()本身在使用。

拜bar()所声明的位置所赐，他拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时间进行引用。

**bar()依然持有对该作用域的引用，而这个引用就叫做闭包**。



## IIFE

IIFE是不是闭包呢？

foo()函数在全局作用域定义，也在全局作用域被立即调用，如果按照定义一的说法来说，它是闭包。如果按照定义二和定义三的说法，它又不是闭包

~~~javascript
var a = 2;
(function foo(){
    console.log(a);//2
})();
~~~



还有一个更重要的原因是，在requireJS出现之前，实现模块化编程主要通过IIFE，而在IIFE中常见的操作就是通过window.fn = fn来暴露接口，而这个fn就是闭包，而IIFE只是一个包含闭包的函数调用

~~~javascript
(function(){
    var a = 0;
    function fn(){
        console.log(a); 
    }
    window.fn = fn;
})()
fn();
~~~



## 总结

闭包定义之所以混乱，我觉得与经典书籍的不同解读有关。经典定义是犀牛书的原话，定义二是高程的原话

但，归纳起来就是关于一个函数要成为一个闭包到底需要满意几个条件

严格来说，闭包需要满足三个条件：【1】访问所在作用域；【2】函数嵌套；【3】在所在作用域外被调用

有些人觉得只满足条件1就可以，所以IIFE是闭包；有些人觉得满足条件1和2才可以，所以被嵌套的函数才是闭包；有些人觉得3个条件都满足才可以，所以在作用域以外的地方被调用的函数才是闭包

问题是，谁是权威呢？













