# 原生函数

常用的原生函数有：

+ String()
+ Number()
+ Boolean()
+ Array()
+ Object()
+ Function()
+ RegExp()
+ Date()
+ Error()
+ Symbol()

实际上他们就是内建函数。

~~~javascript
var str = new String('abc')
console.log(s.toString()) // 'abc'
typeof str // 'object'
str instanceof String // true
Object.prototype.toString.call(str) // '[object String]'
~~~

原生函数可以当做构造函数使用，但其构造出来的对象可能会和我们设想的有所不同。

通过构造函数 (如 `new String('abc')`) 创建出来的是封装了基本类型值 (如 'abc' ) 的封装对象。

再次强调， `new String('abc')` 创建的是字符串 'abc' 的封装对象，而非基本类型值 'abc'。



### 内部属性[[class]]

所有 typeof 返回值为 `object` 的对象都有一个内部属性 `[[class]]`，这个属性无法直接访问，一般通过 `Object.property.toString(..)`来查看

~~~javascript
Object.property.toString.call([1,2,3]) // '[object Array]'
~~~

上面代码中，数组内部的 [[class]] 属性值是 Array，多数情况下，对象内部的 [[class]] 属性和创建该对象的内建原生构造函数相对应。

但并非总是如此：

~~~javascript
Object.property.toString.call(null) // '[object Null]'
Object.property.toString.call(undefined) // '[object Undefined]'
~~~

虽然 null 和 undefined 这样的原生构造函数不存在，但是内部的 [[class]]属性的值仍然是 null 和 undefined。

但对于其他基本类型值却有所不同，

### 封装对象包装

由于基本类型值没有 `.length` 和 `.toString()` 这样的属性和方法，需要通过封装对象才能访问，此时，javascript会自动为基本类型值包装一个封装对象：

~~~javascript
var a = 'abc';
a.length // 3
a.toUpperCase() // ABC
~~~

如果需要经常用到这些字符串和方法，一开始就创建一个封装对象也许更为方便，这样 javascript 引擎就不用每次都自动创建了，

但实际证明这并不是一个好方法，因为浏览器已经为 `.length` 这样常见的情况作了性能优化，直接使用封装对象来 "提前优化" 代码反而会降低执行效率。

一般情况下我们不需要直接使用封装对象，最好的方法是让 javascript 引擎去决定什么时候去使用封装对象，换句话说就是作为开发者应该优先考虑 "a" 和 42 这样的基本类型值而不是 `new String()` 和 `new Number()`。



>封装对象需要注意的是：
>
>var a = new Boolean(false) // 返回一个对象
>
>If (!a) {
>
>​	console.log('opts') // 执行不到这里
>
>}

### 拆封

如果想要得到封装对象中的基本类型值的话可以使用 `valueOf()` 函数：

~~~javascript
var a = new String('a')
var b = new Number(3)
var c = new Boolean(true)

a.valueOf() // 'a'
b.valueOf() // 3
c.valueOf() // true
~~~

在需要用到封装对象的基本类型值的地方会发生隐式拆封。

~~~javascript
var a = new String('a')
var b = a + '' // b的值为a
typeof a // 'object'
typeof b // 'string'
~~~

### 原生函数作为构造函数

关于数组( Array)，对象( Object), 函数( function) 和正则表达式，我们通常喜欢以常量的形式来创建他们，实际上，使用常量使用构造函数的效果是一样的( 创建的值都是通过封装对象来包装 )。

+ Array

  ~~~javascript
  var arr = new Array(1,2,3) // [1,2,3]
  var b = [1,2,3] // [1,2,3]
  ~~~

  构造函数Array(..)不要求必须带new关键字，不带时，它会自动补上。

  Array构造函数只带一个数字参数的时候，该参数会被当做数组的预设长度( length )，而不是去充当数组中的某一个元素。

  **这么做不是一个好的选择：一是容易忘记，二是容易出错**

  更为关键的是，数组并没有预设长度这个概念，这样创建出来的数组其实还是一个空数组，只不过他的 `length` 属性并设置成了指定的值。

  > 如果一个数组没有任何单元，但他的length属性中却显示有单元数量，这样奇特的数据结构会导致一些怪异的行为。
  >
  > 我们将至少包含一个 "空单元" 的数组称为 稀疏数组。



+ Object(..)，Function(..)和RegExp(..)

  同样，除非万不得已，否则不要使用 `Object(..)，Function(..)和RegExp(..)`。

  ~~~javascript
  var c = new Object()
  c.foo = 'bar'
  c // { foo: 'bar' }
  
  var d = { foo: 'bar' }
  d // { foo: 'bar' }
  
  var e = new Function('a', 'return a * 2')
  var f = function (a) { return a * 2 }
  function(a) { return a * 2 }
  
  var h = new RegExp('^a*b+', g)
  var i = /^a*b+/g
  ~~~

  在实际情况中没有必要使用 `new Object()` 来创建对象，因为这样就无法像常量形式那样一次设定多个属性，而必须逐个设定。

  构造函数Function 只在极少数的情况下很有用，比如动态定义函数参数和函数体的时候。不要把`Function(..)`当作 `eval` 的替代品，基本上我们不会通过这种方式来定义函数。

  强烈建议使用常量形式 (如 /^a*b+/g) 来定义正则表达式，这样不仅语法简单，执行效率也更高。



+ Date(..)和Error(..)

  相对于其他与安生构造函数，Date(..) 和 Error(..) 的用处要大很多，因为没有对应的常量形式来作为他们的替代。

  构造函数Error(..) (与前面的Array() 类似) 带不带关键字都可以。

+ 原生原型

  原生构造函数有自己的 `.proprety` 对象，如 Array.property，String.property等。

  这些对象包含其对应子类型的所有特性，

  > 根据文档约定，我们将String.property.xyz简写为String#xyz，对其他.propertype也同样如此。

  ~~~javascript
  String#indexof(..)
  String#charAt(..)
  String#substr(..)
  String#substring(..)
  String#slice(..)
  String#toUpperCase(..)
  String#toLowerCase(..)
  String#trim(..)
  ~~~

  这些方法并不会改变原字符串的值，而是返回一个新的字符串。









